{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to OliDox","text":"<p>Computer Science A Level, documented</p>"},{"location":"#contents","title":"Contents","text":"<ul> <li>1. Components of a Computer</li> <li>2. System Software</li> <li>3. Software Development</li> </ul>"},{"location":"#contribute","title":"Contribute","text":"<p>Add to our documentation on  github</p>"},{"location":"CompSci/1.%20Components%20of%20a%20Computer/","title":"1. Components of a Computer","text":""},{"location":"CompSci/1.%20Components%20of%20a%20Computer/#chapter-2-processor-performance","title":"Chapter 2 - Processor Performance","text":""},{"location":"CompSci/1.%20Components%20of%20a%20Computer/#cache","title":"Cache","text":"<ul> <li>Super fast, expensive memory</li> <li>Stores frequently accessed instructions for quick access.</li> <li>Often made up of 3 different layers<ul> <li>Layer 1 - Extremely fast but small</li> <li>Layer 2 - Fairly fast and medium sized</li> <li>Some CPU\u2019s also have level 3 cache!!</li> </ul> </li> </ul>"},{"location":"CompSci/1.%20Components%20of%20a%20Computer/#pipelining","title":"Pipelining","text":"<ul> <li>Allows a CPU to fetch the next instruction before it executes the previous one.</li> </ul>"},{"location":"CompSci/1.%20Components%20of%20a%20Computer/#cores","title":"Cores","text":"<ul> <li>\u2191 number of cores, communication channels between the cores use up \u2191 of the speed</li> <li>Not all software can make full use of all the cores in a CPU.</li> </ul>"},{"location":"CompSci/1.%20Components%20of%20a%20Computer/#clock-speed","title":"Clock Speed","text":"<ul> <li>\u2191 clock speed, \u2191 number of instructions processed by a CPU in a second</li> <li>\u2191 clock speed, \u2191 CPU temperature</li> <li>Overclocking may result in incomplete execution of instructions and power loss due to heat</li> </ul>"},{"location":"CompSci/10.%20Computational%20Thinking/","title":"3. Computational Thinking","text":""},{"location":"CompSci/10.%20Computational%20Thinking/#chapter-47-thinking-abstractly","title":"Chapter 47 - Thinking Abstractly","text":""},{"location":"CompSci/10.%20Computational%20Thinking/#abstraction","title":"Abstraction","text":"<ul> <li>Removing uncessary detail from problems in order to generalise and solve them.</li> </ul> <ul> <li> <p>The London Underground Map is a abstracted model of the actual geography of the Tube Stations.</p> </li> <li> <p>However it is important to consider what should and should not be abstracted when solving a problem as while this map is very useful for a tourist travelling around London, it is of little use to an engineer planning to dig tunnels for a proposed line.</p> </li> </ul>"},{"location":"CompSci/10.%20Computational%20Thinking/#data-abstraction","title":"Data Abstraction","text":"<ul> <li> <p>Queues, stacks, and trees are also examples of abstraction. </p> </li> <li> <p>They ignore how the data is actually represented in the computer and focus on how data is logically connected.</p> </li> </ul>"},{"location":"CompSci/10.%20Computational%20Thinking/#chapter-48-thinking-ahead","title":"Chapter 48 - Thinking Ahead","text":""},{"location":"CompSci/10.%20Computational%20Thinking/#structured-programming","title":"Structured Programming","text":"<ul> <li>Documenting the inputs, outputs, and precondiitons of an algorithm means that:<ol> <li>It can be put in a library of subroutines and reused from any program.</li> <li>Users know what checks, if any, must be carried out before calling the algorithm.</li> <li>If there are no preconditions, users can be confident that necessary checks will be carried out in the subroutine itself, saving unnecessary coding.</li> </ol> </li> </ul>"},{"location":"CompSci/10.%20Computational%20Thinking/#caching","title":"Caching","text":"<ul> <li>Temporary storage of frequently used program instructions and data.</li> </ul>"},{"location":"CompSci/10.%20Computational%20Thinking/#chapter-49-thinking-procedurally","title":"Chapter 49 - Thinking Procedurally","text":""},{"location":"CompSci/10.%20Computational%20Thinking/#procedural-abstraction","title":"Procedural Abstraction","text":"<p>Procedural abstraction $\\rightarrow$ Decomposing larger problems into sub-problems that can be solved with procedures.</p> <p>When thinking procedurally: - Don't know about how a procedure works. - Know how the procedure is called. - Know what arguments are passed.</p> <p>Breaking down problems using this top-down design breaks down a problem into self contained modules or subroutines. This makes it easier to modify and debug programs as changing modules won't affect the rest of the program.</p>"},{"location":"CompSci/10.%20Computational%20Thinking/#hierarchy-charts","title":"Hierarchy Charts","text":"<p>Represent the structure of a program using a upside down tree model. </p> <p>Shows how each task is decomposed until the entire program is comprised of independant modules, each only a few lines of code long.</p> <p></p>"},{"location":"CompSci/2.%20System%20Software/","title":"2. Systems Software","text":""},{"location":"CompSci/2.%20System%20Software/#chapter-7-functions-of-an-operating-system","title":"Chapter 7 - Functions of an Operating System","text":""},{"location":"CompSci/2.%20System%20Software/#what-does-an-os-do","title":"What does an OS do?","text":"<ul> <li>A user interface to act as a bridge between the user and the hardware</li> <li>Manages memory by allocating RAM to different programs, ensuring that each process gets a share.</li> <li>Processor scheduling and interrupt handling to change what is being processed by the CPU on a priority basis</li> <li>Peripheral management communicates with inputs and outputs. It may transfer data to buffers to compensate for the difference in speed between an output device and the CPU.</li> <li>Backing store management keeps a directory of where files are stored so that they can be quickly accessed.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#chapter-9-the-nature-of-applications","title":"Chapter 9 - The Nature of Applications","text":""},{"location":"CompSci/2.%20System%20Software/#proprietary-software","title":"Proprietary Software","text":"<ul> <li>Regular updates</li> <li>Large user base</li> <li>Technical support lines</li> <li>Training courses</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#chapter-10-programming-language-translators","title":"Chapter 10 - Programming Language Translators","text":""},{"location":"CompSci/2.%20System%20Software/#bytecode","title":"Bytecode","text":"<ul> <li>When Java (or python using the Jython compiler) is compiled into bytecode, it can then be run on any computer with a Java Virtual Machine.</li> <li>The JVM masks the inherent differences between computer architectures and operating systems and converts the bytecode into machine code for that particular computer.</li> <li>This allows for platform independence.</li> <li>Guards against any malicious programs as you are executing the Java bytecode interpreter rather than the program itself.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#lexical-analysis","title":"Lexical analysis","text":"<ul> <li>Superfluous spaces are removed</li> <li>Identified comments are removed</li> <li>Flags up illegal identifiers and values</li> <li>Replaces keywords, constants, and identifiers with tokens.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#symbol-table","title":"Symbol table","text":"<ul> <li>Contains every keyword and identifier in the program</li> <li>Table will show:<ul> <li>kind of item</li> <li>type of item</li> <li>run-time address or its value if its constant</li> <li>a pointer to accessing information</li> </ul> </li> <li>Organised as a hash table so that entries can be found as quickly as possible.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#syntax-analysis","title":"Syntax analysis","text":"<ul> <li>Determines whether the sequence of characters, symbols, and tokens form a valid sentence in the language.</li> <li>Parses each statement to a set of rules using syntax diagrams or Backus-Naur form to determine if it is valid.</li> <li>Fills in kind of item and type of item columns in the symbol table.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#semantic-analysis","title":"Semantic analysis","text":"<ul> <li>Checks whether syntactically correct statements can actually be executed.</li> <li>Examples of errors picked up by semantic analysis would be trying to use an undeclared variable or trying to assign a real value to an integer variable.</li> </ul>"},{"location":"CompSci/2.%20System%20Software/#linkers-and-loaders","title":"Linkers and loaders","text":"<ul> <li>Users running a program will not necessarily have the required libraries installed on their machine</li> <li>Therefore the relevant code needs to be included in the final executable</li> </ul>"},{"location":"CompSci/3.%20Software%20Development/","title":"3. Software Development","text":""},{"location":"CompSci/3.%20Software%20Development/#chapter-11-systems-analysis-methods","title":"Chapter 11 - Systems Analysis Methods","text":""},{"location":"CompSci/3.%20Software%20Development/#waterfall-lifecycle-model","title":"Waterfall lifecycle model","text":"<ol> <li>Analysis</li> <li>Design</li> <li>Implementationdocs/CompSci/3. Software Development.md</li> <li>Evaluation</li> <li>Maintenance</li> </ol> <p>SUITABLE Very small projects which need careful supervision</p> <p>PROBLEM  Absence of user involvement</p>"},{"location":"CompSci/3.%20Software%20Development/#spiral-model","title":"Spiral model","text":"<p>See waterfall lifecycle model and just picture it as a spiral :)</p> <ul> <li>Develops the software in iterative stages</li> <li>Works towards prototypes, refining it at each stage.</li> </ul> <p>SUITABLE Large scale projects that take years to deliver</p>"},{"location":"CompSci/3.%20Software%20Development/#agile-modelling","title":"Agile modelling","text":"<ul> <li>Stages of software development are not completed in a linear sequence</li> <li>At each stage:<ul> <li>a prototype is built</li> <li>and feedback is obtained from the user.</li> </ul> </li> </ul> <p>SUITABLE Smaller projects where user requirements can change</p>"},{"location":"CompSci/3.%20Software%20Development/#extreme-programming","title":"Extreme programming","text":"<p>See agile modelling but with more releases</p> <ul> <li>Short development cycles</li> <li>Introduces checkpoints at which new customer requirements can be adopted</li> <li>Improves productivity</li> </ul> <p>SUITABLE Large projects where there is a danger of getting sidetracked by suggested improvements</p>"},{"location":"CompSci/3.%20Software%20Development/#rapid-application-development","title":"Rapid application development","text":"<p>See agile modelling</p> <ul> <li>Workshop and focus groups to gather requirements rather than a formal requirement document</li> <li>Producing each part of the system within a strict time limit which may not be perfect but \u201cgood enough\u201d</li> <li>Reusing any software which has already been used elsewhere.</li> </ul> <p>SUITABLE Good for very large products that will be developed over time where both technology and user requirements are subject to change.</p>"},{"location":"CompSci/General%20Notes/","title":"General Notes","text":""},{"location":"CompSci/General%20Notes/#array-vs-linked-list","title":"Array vs Linked List","text":"Array Linked List Static data structure Dynamic data structure Ability to have any element accessed randomly Linked list needs to be traversed until the desired element is found Contents are stored contiguously in memory Contents may not be stored contiguously in memory"}]}